package com.mk.fx.qa.qap.junit.extension;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtensionContext;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Resolves display names and parent hierarchies for JUnit test contexts.
 * Handles @DisplayName annotations, nested test classes, and parameterized tests.
 */
public class DisplayNameResolver {

    private static final String EMPTY_PARENTHESES = "()";
    private static final String OPEN_PARENTHESIS = "(";

    /**
     * Resolves the display name for a specific test run.
     * For parameterized tests, preserves the dynamic run name (e.g., "Run 1 with value=A").
     * Falls back to @DisplayName annotation or method name.
     */
    public String resolveRunDisplayName(ExtensionContext context, String methodName, String rawDisplayName) {
        if (context.getTestMethod().isEmpty()) {
            return isAutoGeneratedDisplayName(rawDisplayName, methodName) ? methodName : rawDisplayName;
        }
        
        Method testMethod = context.getRequiredTestMethod();

        // Keep parameterized run names intact (e.g. "Run 1 with value=A")
        if (!isAutoGeneratedDisplayName(rawDisplayName, methodName)) {
            return rawDisplayName;
        }

        // Fallback: method-level @DisplayName
        DisplayName junitDisplayName = testMethod.getAnnotation(DisplayName.class);
        if (junitDisplayName != null) {
            return junitDisplayName.value();
        }

        return methodName;
    }

    /**
     * Resolves the static method-level display name from @DisplayName annotation.
     * Returns the method name if no annotation is present.
     */
    public String resolveMethodDisplayName(ExtensionContext context) {
        return context.getTestMethod()
                .map(m -> {
                    DisplayName dn = m.getAnnotation(DisplayName.class);
                    return (dn != null) ? dn.value() : m.getName();
                })
                .orElse("");
    }

    /**
     * Resolves the class-level display name from @DisplayName annotation.
     * Returns the simple class name if no annotation is present.
     */
    public String resolveClassDisplayName(ExtensionContext context) {
        return context.getTestClass()
                .map(c -> {
                    DisplayName dn = c.getAnnotation(DisplayName.class);
                    return (dn != null) ? dn.value() : c.getSimpleName();
                })
                .orElse("");
    }

    /**
     * Resolves the fully qualified class name (FQCN) of the test class.
     */
    public String resolveParentClassKey(ExtensionContext context) {
        return context.getTestClass()
                .map(Class::getName)
                .orElse(null);
    }

    /**
     * Builds the parent chain from the root test class down to (but not including) 
     * the current test class. This handles nested test classes properly.
     * 
     * For example, if the hierarchy is:
     * - NestedTestsExample (top-level)
     *   - FirstNested
     *     - SecondLevelNested (current)
     * 
     * This returns: ["NestedTestsExample", "FirstNested"]
     * 
     * The current class should be added separately by the caller.
     */
    public List<String> buildParentChain(ExtensionContext context) {
        List<String> chain = new ArrayList<>();
        
        // Get the current test's class to exclude it from the chain
        Optional<Class<?>> currentTestClass = context.getTestClass();
        
        Optional<ExtensionContext> parent = context.getParent();
        
        while (parent.isPresent()) {
            ExtensionContext ctx = parent.get();
            ctx.getTestClass().ifPresent(cls -> {
                // Only add if it's NOT the current test class
                if (currentTestClass.isEmpty() || !cls.equals(currentTestClass.get())) {
                    DisplayName dn = cls.getAnnotation(DisplayName.class);
                    String name = (dn != null) ? dn.value() : cls.getSimpleName();
                    chain.add(0, name); // Prepend to maintain top-down order
                }
            });
            parent = ctx.getParent();
        }
        
        return chain;
    }

    /**
     * Checks if a display name is auto-generated by JUnit (not custom).
     * JUnit generates names like "methodName()" or "methodName(Type)" for methods.
     */
    private boolean isAutoGeneratedDisplayName(String displayName, String methodName) {
        return displayName.equals(methodName + EMPTY_PARENTHESES)
                || displayName.startsWith(methodName + OPEN_PARENTHESIS)
                || displayName.equals(methodName);
    }
}